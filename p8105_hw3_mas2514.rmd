---
title: "P8105 Homework 3"
author: "Maria Serafini"
output: github_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(patchwork)
library(p8105.datasets)

knitr::opts_chunk$set(
  fig.width = 8,
  fig.height = 5,
  fig.asp = .6,
  out.width = "90%", 
  collapse = TRUE, 
  messgae = FALSE
  )

theme_set(theme_minimal() + theme(legend.position = "bottom"))

options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis"
  )

scale_colour_discrete = scale_colour_viridis_d(option = "magma")
scale_fill_discrete = scale_fill_viridis_d(option = "magma")
```

## Problem 1

__This code chunk loads the p8105 `instacart` data, which is a clean and limited version of The "Instacart Online Grocery Shopping Dataset 2017" and contains information about instacart online grocery orders__

```{r load_p8105_instacart}
data("instacart")
```

The `instacart` data contains `r nrow(instacart)` observations and `r ncol(instacart)` variables and provides information on the instacart grocery orders of `r instacart |> summarize(n = n_distinct(user_id))` users with each row representing a product from an order. The `product_name` variable identifies the product ordered, the `aisle` variable indicates which aisle the ordered item came from, and the `department` describes the grocery store department the ordered item belongs to. For example, the department with the most ordered items was the `r instacart |> group_by(department) |> summarize(items_ordered = n()) |> arrange(desc(items_ordered)) |> slice_head(n = 1) |> pull(department) |> paste()` department and the most ordered item was `r instacart |> group_by(product_name) |> summarize(items_ordered = n()) |> arrange(desc(items_ordered)) |> slice_head(n = 1) |> pull(product_name) |> paste()`s. The dataset also includes the variables `add_to_cart_order`, which gives the sequence of products purchased in each order, and `reorder`, which indicates whether that item was ordered by the user in the past. The week and hour of day the order was placed is given by `order_dow` and `order_hour_of_day`, respectively. 

There are a total of `r instacart |> summarize(n = n_distinct(aisle))` aisles and the three aisles with the most items ordered are `r instacart |> group_by(aisle) |> summarize(items_ordered = n()) |> arrange(desc(items_ordered)) |> slice_head(n = 3) |> pull(aisle) |> paste(collapse = ", ")` with `r instacart |> group_by(aisle) |> summarize(items_ordered = n()) |> arrange(desc(items_ordered)) |> slice_head(n = 3) |> pull(items_ordered) |> paste(collapse = ", ")` items ordered for each aisle, respectively.

#
__The code chunk below creates a plot of the number of items ordered per aisle. We group by aisle and count the number of items ordered per aisle, filtering to only include aisles with 10,000 or more items ordered. We then create a plot to visualize the number of items ordered per aisle with the aisles arranged from most to least number of items ordered. We remove the legend for clarity and add labels for readability__

The plot below shows the number of grocery items ordered per aisle for aisles with more than 10,000 items ordered. We can observe that the aisles, fresh vegetables, fresh fruits, and packaged vegetables and fruits had the most ordered items confirming our observations above. Only these three aisles and the yogurt aisle had over 50,000 items ordered. 

```{r plot_orders_by_aisle, fig.width = 10}
instacart |> 
  group_by(aisle) |> 
  summarize(
    aisle_items_ordered = n()
  ) |> 
  filter(aisle_items_ordered > 10000) |> 
  ggplot(aes(x = aisle_items_ordered, y = reorder(aisle, aisle_items_ordered), fill = aisle)) +
  geom_col() +
  theme(legend.position = "none") +
  labs(
    x = "Number of Items Ordered", 
    y = "Aisle", 
    title = "Number of Grocery Items Ordered Per Aisle",
    subtitle = "(More than 10,000 Items Ordered)"
  )
```

# 
The table below shows the top 3 most popular items (most ordered) for the aisles "Baking Ingredients", "Dog Food Care", and "Packages Vegetables Fruits". The top three ordered baking items were "Light Brown Sugar" with 499 orders, "Pure Baking Soda" with 387 orders, and "Cane Sugar" with 336 orders. The top three most ordered dog food items were "Snack Sticks Chicken & Rice Recipe Dog Treats" with 30 orders, "Organix Chicken & Brown Rice Recipe" with 28 orders, and "Small Dog Biscuits" with 26 orders. Finally, the top three items ordered from packaged vegetables and fruits were "Organic Baby Spinach" with 9,784 orders, "Organic Raspberries" with 5,546 orders, and "Organic Blueberries" with 4,966 orders. 

```{r plot_top3_items_by_aisle}
instacart |> 
  filter(aisle %in% c("baking ingredients", "dog food care", "packaged vegetables fruits")) |>
  mutate(
    aisle = case_match(
      aisle,
      "baking ingredients" ~ "Baking Ingrdients",
      "dog food care" ~ "Dog Food Care",
      "packaged vegetables fruits" ~ "Packaged Vegetables Fruits"
    )
  ) |> 
  group_by(aisle, product_name) |> 
  summarize(
    item_count = n(), .groups = "drop_last"
  ) |> 
  arrange(aisle, desc(item_count)) |> 
  slice_head(n = 3) |>
  knitr::kable(
    col.names = c("Aisle", "Item Name", "Number of Orders")
  )
```

# 
The table below shows the mean hour of the day each of the products, Coffee Ice Cream and Pink Lady Apples, were ordered for each day of the week. The earliest mean hour of the day Coffee Ice Cream was ordered was 12.26 on Friday and the latest mean hour was 15.38 on Tuesday. The earliest mean hour of the day Pink Lady Apples were ordered was 11.36 on Monday and the latest was 14.25 on Wednesday. Overall the mean hour of the day Pink lady Apples were ordered was earlier than the mean hour of the day Coffee Ice Cream was ordered for all days except Friday (12.78 vs 12.26, respectively). 

```{r table_mean_hour}
instacart |> 
  filter(product_name %in% c("Pink Lady Apples", "Coffee Ice Cream")) |> 
  mutate(
    order_dow = case_match(
      order_dow,
      0 ~ "Sunday",
      1 ~ "Monday",
      2 ~ "Tuesday", 
      3 ~ "Wednesday", 
      4 ~ "Thursday", 
      5 ~ "Friday",
      6 ~ "Saturday"),
    order_dow = factor(
      order_dow,
      levels = c("Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"),
      ordered = TRUE)
    ) |> 
  group_by(product_name, order_dow) |> 
  summarize(
    mean_hour_of_day = mean(order_hour_of_day, na.rm = TRUE), .groups = "drop"
  ) |> 
  pivot_wider(
    names_from = order_dow,
    values_from = mean_hour_of_day
  ) |> 
  arrange(product_name) |> 
  rename("Item Name" = product_name) |> 
  knitr::kable(digits = 2)
```


## Problem 2

__The code chunk below imports and cleans the Zillow NYC rental data and ZIP code data. We convert the rental price data to long format and create a year variable. In the ZIP code data, we change county name to borough and remove incorrect entries for repeated zip codes. We then join the datasets by ZIP code to create a NYC rental dataset__

```{r load_zillow_zip_data, message = FALSE}
nyc_zori_df <-
  read_csv("data/Zip_zori_uc_sfrcondomfr_sm_month_NYC.csv") |> 
  pivot_longer(
    -(RegionID:CountyName),
    names_to = "month",
    values_to = "price") |> 
  janitor::clean_names() |> 
  rename(zip_code = region_name) |> 
  mutate(
    month = as_date(month),
    year = floor_date(month, unit = "year"),
    zip_code = as.numeric(zip_code)) |> 
  select(-county_name)

zip_codes_df <-
  read_csv("data/Zip Codes.csv") |> 
  janitor::clean_names() |> 
  filter(
    !(zip_code == 10463 & county == "New York"),
    !(zip_code == 11201 & county == "New York")) |> 
  mutate(
    borough = case_match(
      county,
      "Bronx" ~ "Bronx",
      "Kings" ~ "Brooklyn",
      "New York" ~ "Manhattan",
      "Queens" ~ "Queens",
      "Richmond" ~ "Staten Island"
    )
  ) |> 
  select(zip_code, borough, neighborhood)

nyc_rental_df = 
  left_join(nyc_zori_df, zip_codes_df, by = "zip_code")
```

There are `r nyc_rental_df |> group_by(zip_code) |> summarize(zipcode_count = sum(!is.na(price)), .groups = "drop") |> filter(zipcode_count == 116) |> nrow()` zip codes observed in all 116 months between January 2015 and August 2024 and  `r nyc_rental_df |> group_by(zip_code) |> summarize(zipcode_count = sum(!is.na(price)), .groups = "drop") |> filter(zipcode_count < 10) |> nrow()` zip codes observed in fewer than 10 of the months. The zip codes that appear in every month, such as 10001 and 10014 correspond to popular neighborhoods of NYC (Chelsea and West Village) with high demand rental markets leading to consistent representation in the rental data. The ZIP codes observed in fewer than 10 of the months may be areas with sparse or less consistent rental listings, only appearing in the data for months with a higher volume of rental listings.    

# 
The table below shows the mean rental price in each borough of NYC by year. From the table we can observe that Manhattan has the highest rental prices on average followed by Brooklyn and Queens. We can also see a clear trend of increasing average rental prices in these boroughs until 2020 and 2021, where there is a noticeable decrease in average prices followed by an increase in 2022. We can also observe a consistent increase in mean rental prices in the Bronx from 2016 to 2024. Notably, Staten Island did not have rental price data included in the dataset prior to 2020, suggesting the rental market became more consistent in this borough during that time. 

```{r table_mean_rent_price}
nyc_rental_df |> 
  group_by(borough, year) |> 
  summarize(mean_price = mean(price, na.rm = TRUE), .groups = "drop") |> 
  pivot_wider(
    names_from = borough, 
    values_from = mean_price
  ) |> 
  mutate(year = year(as.Date(year))) |> 
  rename("Year" = year) |> 
  knitr::kable(digits = 0)
```


# 
The plot below shows NYC rental prices within each ZIP code by available year and separated by borough with each line representing a ZIP code within each respective borough. Looking at the plot, we can see that Manhattan and Brooklyn rental prices were fairly stable across ZIP codes through 2020, with a significant decrease in prices between 2020 and 2021 and a significant increase bwtween 2021 and 2022. This noticable dip represents the decrease in rental prices following the COVID-19 pandemic as residents temporarily and permanantly left the city and the demand for rentals decreased, followed by the increased demand for rentals following the end of COVID-19 lockdowns. From 2022 to 2024, rental prices in Manhattan and Brooklyn have steadily increased. Rental prices in the Bronx and Queens have remained fairly stable with a slight increasing trend across years.Staten Island rental prices also appear to be mostly consistent across ZIP Codes and steadily increasing year-to-year. It is notable that Staten Island did not have any data on rental prices prior to 2020, suggesting a growing rental market in this borough.     

```{r nyc_yearly_rental_plot}
nyc_yearly_rental_plot <- 
  nyc_rental_df |> 
  select(zip_code, price, month, year, borough) |> 
  mutate(
    zip_code = as.factor(zip_code)
  ) |> 
  drop_na() |> 
  ggplot(aes(x = month, y = price, group = zip_code, color = zip_code)) +
  geom_line(alpha = 0.5, linewidth = 0.4) +
  theme(legend.position = "none") +
  facet_wrap(~borough, ncol = 2) +
  labs(
    title = "Rental Prices Within NYC Zip Codes by Year and Borough",
    x = "Year",
    y = "Rental Price (Dollars)")

print(nyc_yearly_rental_plot)
```


# 
The plot below shows the distribution of the average monthly ZIP code-level rental prices across the boroughs of NYC in 2023. Looking at the plot, we can see that Manhattan has the highest rental prices and widest spread indicating large variability in prices between ZIP codes. Brooklyn's average monthly rental prices are lower when compared to Manhattan, but still show moderate variability between ZIP codes. Bronx, Queens, and Staten Island have the lowest average rental prices and less spread, suggesting similar and generally more affordable rental prices across ZIP codes. However, Queens has a number of outlying ZIP codes with much higher rental prices than the average for the borough, indicating that number of ZIP codes in this borough are significantly more expensive for renters. 

```{r nyc_rental_2023_plot}
nyc_rental_2023_plot <- 
  nyc_rental_df |> 
  filter(year %in% "2023-01-01") |> 
  select(zip_code, price, month, year, borough) |> 
  group_by(borough, zip_code, month) |> 
  summarize(
    mean_price = mean(price, na.rm = TRUE), .groups = "drop"
  ) |> 
  drop_na() |> 
  ggplot(aes(x = borough, y = mean_price, fill = borough))+
  geom_violin(alpha = 0.5, trim = FALSE) +
  geom_boxplot(alpha = 0.5, outlier.shape = 1.0) +
  labs(
    title = "Distribution of Average Monthly ZIP Code-level Rental Prices Across NYC",
    x = "Borough", 
    y = "Average Monthly Rental Price (Dollars)"
  ) +
  theme(legend.position = "none")

print(nyc_rental_2023_plot)
```

#
__This code chunk combines the `nyc_yearly_rental_plot` and `nyc_rental_2023_plot` above using patchwork__

```{r combined_rental_plots, fig.width= 10}
combined_rental_plot <- 
  nyc_yearly_rental_plot + nyc_rental_2023_plot

print(combined_rental_plot)
ggsave("results/combined_rental_plot.png", plot = combined_rental_plot, width = 10, height = 8)
```


## Problem 3

__This chunk loads, cleans, and merges the demographic and accelerometer data of 250 participants in the National Health and Nutrition Examination Survey (NHANES). The demographic data is filtered to exclude participants less than 21 year old and participants with missing demographic data; we also encode the education variable as a factor variable in order of increasing education level. The accelerometer data is converted to long format and we created minute of the day and mims value  variables; we also encode the minute of day variable as a factor variable in ascending order of minutes of the day over 24 hours. We then join the two datasets using the participant's respondent sequence number__

```{r load_nhanes_data, message = FALSE}
nhanes_demo_df <- 
  read_csv("data/nhanes_covar.csv", skip = 4, na = c("NA", "")) |> 
  janitor::clean_names() |> 
  filter(age >= 21) |> 
  mutate(
    sex = case_match(
      sex,
      1 ~ "male",
      2 ~ "female"),
   education = factor(
     education, 
     levels = c(1, 2, 3), 
     labels = c("Less than high school", "High school equivalent", "More than high school")
     )
   ) |> 
  drop_na()

nhanes_accel_df <-
  read_csv("data/nhanes_accel.csv", na = c("NA", "")) |> 
  janitor::clean_names() |> 
  pivot_longer(
    cols = min1:min1440,
    names_to = "minute_of_day", 
    values_to = "mims_value",
  ) |> 
  separate(minute_of_day, into = c("min", "minute_of_day"), sep = 3) |> 
  select(-min) |> 
  mutate(
    minute_of_day = factor(minute_of_day, levels = c(1:1440))
  )

nhanes_df <-
  left_join(nhanes_demo_df, nhanes_accel_df, by = "seqn")
```

# 
The table below shows the number of male and female participants from the sample who are in each education group. From the table, we can observe that the majority of participants of both sexes have a level of education more than high school. The distribution of males and females is fairly even in the less than high shcool group (22.9% vs. 25.5%, respectively). For high school equivalent group, there is a higher percentage of males than females (29.7% vs. 20.9%, respectively) and for the more than high school group there are is a higher percentage of females than males (53.6% vs. 47.5%, respectively).

```{r table_education_sex}
nhanes_df |> 
  select(seqn, sex, education) |> 
  group_by(sex, education) |> 
  summarize(
    count_sex = n_distinct(seqn), .groups = "drop"
  ) |> 
  pivot_wider(
    names_from = sex, 
    values_from = count_sex
  ) |> 
  rename(
    "Education Level" = education,
    "Female (n)" = female, 
    "Male (n)" = male
  ) |> 
  knitr::kable()
```

# 
The plot below show the age distribution of male and female participants across education levels. From this distribution, we can observe the wide range of ages represented in the data for both males and females across education levels. There appears to be a higher concentration of females below 50 years of age with more than a high school education when compared to the less than high school and high school equivalent groups. There appears to be a higher concentration of middle and older age males with less than a high school education compared to the high school equivalent and more than high school groups which are more evenly distributed.  

```{r plot_age_dist}
nhanes_df |> 
  select(sex, education, age) |> 
  drop_na() |> 
  ggplot(aes(x = sex, y = age, fill = education)) +
  geom_violin(alpha = 0.5) +
  labs(
    title = "Age Distribution of Female and Male Participants By Education Level",
    x = "Sex",
    y = "Age", 
    fill = "Education Level"
  ) +
  scale_y_continuous(
    limits = c(0,90)
  )
```

# 
The plot below shows total activity (aggregated mims) for each participant by age with colors representing sex and separated by education level. For participants with less than a high school education, total activity appears to be higher in females compared with males across most ages, with both groups showing a general decline in activity after approximately 60 years of age. For those with a high school equivalent education, activity patterns were more similar between sexes, though both exhibited noticeable fluctuations and a decline in later adulthood. In contrast, participants with more than a high school education maintained relatively consistent activity levels across age, and differences between males and females were minimal. Overall, the plot suggest that a higher educational level may be associated with more stable activity patterns across adulthood and smaller sex differences in total activity levels.

```{r plot_total_activity, message = FALSE}
nhanes_df |> 
  group_by(seqn) |> 
  mutate(
    total_activity = sum(mims_value),
  ) |> 
  ggplot(aes(x = age, y = total_activity, color = sex)) +
  geom_point(alpha = 0.5) +
  geom_smooth() +
  facet_wrap(education~.) +
  labs(
    title = "Total Activity By Age Between Females and Males of Different Education Levels",
    x = "Age (Years)",
    y = "Total Activity (Aggregate MIMS)"
  )
```


# 
The plot below shows 24-hour activity time courses (mean MIMS) with colors representing sex and separated by education level. Across all groups, we see a diurnal pattern of activity with low activity levels during nighttime, a rapid increase in activity levels following wake time, high activity levels during daytime, and a rapid decrease in activity levels following sleep time. For the less than high school group, the peak average daytime activity level is higher in both females and males compared to the other groups. However, daytime activity levels in the less than high school group decline following the daytime peak, while daytime activity levels in the high school equivalent and more than high school groups remain relatively stable following the peak before declining sharply at sleep time. This suggests that education level may correspond to more consistent daily activity levels. From the plot, we can also observe that female participants show higher average daytime activity levels than males across all education levels.

```{r plot_24hr_activity, width = 10, message = FALSE}
nhanes_df |> 
  mutate(
    minute_of_day = as.numeric(minute_of_day),
    ) |> 
  group_by(sex, education, minute_of_day) |> 
  summarize(
    mean_mims = mean(mims_value), .groups = "drop" 
  ) |> 
  drop_na() |> 
  ggplot(aes(x = minute_of_day, y = mean_mims, color = sex, group = sex)) +
  geom_line(alpha = 0.5) +
  geom_smooth(se = FALSE) +
  facet_wrap(education~.) +
  labs(
    title = "24-hour Activity Time Courses By Education Level", 
    x = "Time", 
    y = "Mean MIMS",
    color = "Sex"
  ) +
  scale_x_continuous(
    limits = c(0, 1440), 
    breaks = seq(0, 1440, by = 360),
    labels = function(m) {
    labs <- sprintf("%02d:00", (m %% 1440) %/% 60)
    labs[m == 1440] <- "24:00"
    labs
    }
  )
```

